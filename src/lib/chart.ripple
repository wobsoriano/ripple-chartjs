import { Chart as ChartJS } from 'chart.js';
import type { ChartType, DefaultDataPoint } from 'chart.js';
import type { ChartProps } from './types';
import { effect, track, untrack } from 'ripple';
import { cloneData } from './utils';
import { setOptions, setDatasets, setLabels } from './utils';

const watch = (deps: Array<any>, cb: () => void) => {
	let first = true;

	effect(() => {
		deps.forEach((dep, index) => deps[index]);

		if (first) {
			first = false;

			return;
		}

		return untrack(cb);
	});
};

export component Chart(props: ChartProps<ChartType, DefaultDataPoint<ChartType>>) {
	const { height, width, redraw, datasetIdKey, type, data, options, plugins, updateMode } = props;

	let canvasNode = track()
	let chart = track()

	effect(() => {
		console.log('data', data.labels[0]);
	})

	const renderChart = () => {
		if (!@canvasNode) {
			return;
		}


		@chart = new ChartJS(@canvasNode, {
			type,
			data: cloneData(data, datasetIdKey),
			options: options && {
				...options,
			},
			plugins,
		});
	};

	const destroyChart = () => {
		if (@chart) {
			@chart.destroy();
			@chart = null;
		}
	};

	watch([options], () => {
		if (!redraw && @chart && options) {
			setOptions(@chart, @options);
		}
	});

	const datasets = data.datasets;
	const labels = data.labels;

	watch([labels], () => {
		if (!redraw && @chart) {
			setLabels(@chart.config.data, labels);
		}
	});

	watch([datasets], () => {
		if (!redraw && @chart && datasets) {
			setDatasets(@chart.config.data, datasets, datasetIdKey);
		}
	});

	watch([options, @datasets, @labels], () => {
		if (!@chart) {
			return;
		}

		if (redraw) {
			destroyChart();
			setTimeout(renderChart);
		} else {
			@chart.update(updateMode);
		}

	});

	watch([type], () => {
		destroyChart();
		renderChart();
	});

	effect(() => {
		untrack(renderChart);

		return destroyChart;
	});

	<canvas {ref node => {
			@canvasNode = node;

			return () => @canvasNode = undefined;
		}} role='img' height={height} width={width} />
}
